{"noir_version":"1.0.0-beta.3+ceaa1986628197bd1170147f6a07f0f98d21030a","hash":17202875825998071106,"abi":{"parameters":[{"name":"message","type":{"kind":"array","length":46,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"msg_hash","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"signature","type":{"kind":"array","length":64,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"pubkey_x","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"pubkey_y","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"}],"return_type":null,"error_types":{"2920182694213909827":{"error_kind":"string","string":"attempt to subtract with overflow"},"5019202896831570965":{"error_kind":"string","string":"attempt to add with overflow"},"7233212735005103307":{"error_kind":"string","string":"attempt to multiply with overflow"},"14514982005979867414":{"error_kind":"string","string":"attempt to bit-shift with overflow"},"16761564377371454734":{"error_kind":"string","string":"Array index out of bounds"},"17843811134343075018":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"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","file_map":{"18":{"source":"pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    fn _to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    fn _to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = self._to_le_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = self._to_be_bits();\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // `_radix` must be less than 256\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n","path":"std/field/mod.nr"},"62":{"source":"use sha256::sha256;\nfn main(\n    message: [u8; 46],\n    msg_hash: [u8; 32],\n    signature: [u8; 64],\n    pubkey_x: [u8; 32],\n    pubkey_y: [u8; 32],\n) {\n    let computed_hash: [u8; 32] = sha256::sha256(message);\n    assert(computed_hash == msg_hash);\n    let sig_valid: bool =\n        std::ecdsa_secp256k1::verify_signature(pubkey_x, pubkey_y, signature, msg_hash);\n    assert(sig_valid == true)\n}\n#[test]\nfn test_valid_signature() {\n    let message: [u8; 46] = [\n        0x47, 0x65, 0x6e, 0x65, 0x72, 0x61, 0x6c, 0x45, 0x6c, 0x65, 0x63, 0x74, 0x72, 0x69, 0x63,\n        0x7c, 0x46, 0x65, 0x72, 0x67, 0x75, 0x73, 0x6f, 0x6e, 0x7c, 0x31, 0x36, 0x36, 0x30, 0x30,\n        0x30, 0x7c, 0x53, 0x52, 0x4e, 0x39, 0x33, 0x37, 0x35, 0x38, 0x30, 0x32, 0x38, 0x35, 0x35,\n        0x7c,\n    ];\n\n    let msg_hash: [u8; 32] = [\n        0xe3, 0xa6, 0x26, 0x68, 0x19, 0xf3, 0x4d, 0xd1, 0xaf, 0x14, 0x7c, 0x47, 0x91, 0xd4, 0xef,\n        0x92, 0x41, 0xd9, 0xe3, 0xf8, 0x07, 0xc6, 0xb3, 0x40, 0xe7, 0x94, 0x42, 0x8d, 0x6b, 0x8e,\n        0xba, 0x7a,\n    ];\n\n    let signature: [u8; 64] = [\n        0x12, 0x8e, 0xcc, 0x34, 0xd9, 0xca, 0x40, 0xa6, 0x56, 0xcd, 0x2b, 0x53, 0x74, 0xe7, 0x37,\n        0xda, 0x0c, 0x41, 0x84, 0x8e, 0x17, 0x45, 0x96, 0xbb, 0xd0, 0xec, 0x6d, 0x94, 0xdf, 0xb1,\n        0xf2, 0x05, 0x55, 0x3c, 0x7a, 0xe7, 0x5d, 0x26, 0x7c, 0x93, 0xdf, 0xc7, 0x4f, 0xb2, 0x17,\n        0x9c, 0x3e, 0x6d, 0x4b, 0x25, 0x27, 0x64, 0x73, 0xee, 0x66, 0x92, 0xa4, 0x4d, 0xab, 0x0e,\n        0x85, 0x3b, 0x8d, 0xba,\n    ];\n\n    let pubkey_x: [u8; 32] = [\n        0xab, 0x8f, 0x04, 0x5d, 0x2f, 0xdc, 0x31, 0x88, 0x0e, 0x6c, 0x7b, 0x54, 0x03, 0x94, 0x2c,\n        0x0e, 0xb1, 0x56, 0x2b, 0xa5, 0xd3, 0x1e, 0x3b, 0xb5, 0x1e, 0x7f, 0x68, 0x74, 0xae, 0xd2,\n        0x94, 0x90,\n    ];\n\n    let pubkey_y: [u8; 32] = [\n        0x82, 0x1d, 0x6d, 0xba, 0x2d, 0xa8, 0xc0, 0xaa, 0xd7, 0xef, 0x51, 0x64, 0x65, 0xb8, 0xc2,\n        0x8a, 0x72, 0x78, 0x2e, 0x9e, 0xe6, 0x2d, 0x96, 0x72, 0xa9, 0x8e, 0xff, 0xeb, 0x8d, 0x07,\n        0xf9, 0x5b,\n    ];\n    main(message, msg_hash, signature, pubkey_x, pubkey_y);\n\n    // assert(main(msg_hash, signature, pubkey_x, pubkey_y) == true);\n}\n","path":"/Users/sanjaysirangi/Desktop/zkpay/src/main.nr"},"66":{"source":"use std::hash::sha256_compression;\nuse std::runtime::is_unconstrained;\n\nmod tests;\n\n// Implementation of SHA-256 mapping a byte array of variable length to\n// 32 bytes.\n\n// A message block is up to 64 bytes taken from the input.\nglobal BLOCK_SIZE: u32 = 64;\n\n// The first index in the block where the 8 byte message size will be written.\nglobal MSG_SIZE_PTR: u32 = 56;\n\n// Size of the message block when packed as 4-byte integer array.\nglobal INT_BLOCK_SIZE: u32 = 16;\n\n// A `u32` integer consists of 4 bytes.\nglobal INT_SIZE: u32 = 4;\n\n// Index of the integer in the `INT_BLOCK` where the length is written.\nglobal INT_SIZE_PTR: u32 = MSG_SIZE_PTR / INT_SIZE;\n\n// Magic numbers for bit shifting.\n// Works with actual bit shifting as well as the compiler turns them into * and /\n// but circuit execution appears to be 10% faster this way.\nglobal TWO_POW_8: u32 = 256;\nglobal TWO_POW_16: u32 = TWO_POW_8 * 256;\nglobal TWO_POW_24: u32 = TWO_POW_16 * 256;\nglobal TWO_POW_32: u64 = TWO_POW_24 as u64 * 256;\n\n// Index of a byte in a 64 byte block; ie. 0..=63\ntype BLOCK_BYTE_PTR = u32;\n\n// The foreign function to compress blocks works on 16 pieces of 4-byte integers, instead of 64 bytes.\ntype INT_BLOCK = [u32; INT_BLOCK_SIZE];\n\n// A message block is a slice of the original message of a fixed size,\n// potentially padded with zeros, with neighbouring 4 bytes packed into integers.\ntype MSG_BLOCK = INT_BLOCK;\n\n// The hash is 32 bytes.\ntype HASH = [u8; 32];\n\n// The state accumulates the blocks.\n// Its overall size is the same as the `HASH`.\ntype STATE = [u32; 8];\n\n// Deprecated in favour of `sha256_var`\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> HASH\n// docs:end:sha256\n{\n    digest(input)\n}\n\n// SHA-256 hash function\n#[no_predicates]\npub fn digest<let N: u32>(msg: [u8; N]) -> HASH {\n    sha256_var(msg, N as u64)\n}\n\n// Variable size SHA-256 hash\npub fn sha256_var<let N: u32>(msg: [u8; N], message_size: u64) -> HASH {\n    let message_size = message_size as u32;\n    let num_blocks = N / BLOCK_SIZE;\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n    // Intermediate hash, starting with the canonical initial value\n    let mut h: STATE = [\n        1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635,\n        1541459225,\n    ];\n    // Pointer into msg_block on a 64 byte scale\n    let mut msg_byte_ptr = 0;\n    for i in 0..num_blocks {\n        let msg_start = BLOCK_SIZE * i;\n        let (new_msg_block, new_msg_byte_ptr) =\n            unsafe { build_msg_block(msg, message_size, msg_start) };\n\n        if msg_start < message_size {\n            msg_block = new_msg_block;\n        }\n\n        if !is_unconstrained() {\n            // Verify the block we are compressing was appropriately constructed\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n            }\n        } else if msg_start < message_size {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n\n        // If the block is filled, compress it.\n        // An un-filled block is handled after this loop.\n        if (msg_start < message_size) & (msg_byte_ptr == BLOCK_SIZE) {\n            h = sha256_compression(msg_block, h);\n        }\n    }\n\n    let modulo = N % BLOCK_SIZE;\n    // Handle setup of the final msg block.\n    // This case is only hit if the msg is less than the block size,\n    // or our message cannot be evenly split into blocks.\n    if modulo != 0 {\n        let msg_start = BLOCK_SIZE * num_blocks;\n        let (new_msg_block, new_msg_byte_ptr) =\n            unsafe { build_msg_block(msg, message_size, msg_start) };\n\n        if msg_start < message_size {\n            msg_block = new_msg_block;\n        }\n\n        if !is_unconstrained() {\n            let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n            if msg_start < message_size {\n                msg_byte_ptr = new_msg_byte_ptr;\n                verify_msg_block_padding(msg_block, msg_byte_ptr);\n            }\n        } else if msg_start < message_size {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n    }\n\n    // If we had modulo == 0 then it means the last block was full,\n    // and we can reset the pointer to zero to overwrite it.\n    if msg_byte_ptr == BLOCK_SIZE {\n        msg_byte_ptr = 0;\n    }\n\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    // Here we rely on the fact that everything beyond the available input is set to 0.\n    msg_block = update_block_item(\n        msg_block,\n        msg_byte_ptr,\n        |msg_item| set_item_byte_then_zeros(msg_item, msg_byte_ptr, 1 << 7),\n    );\n    msg_byte_ptr = msg_byte_ptr + 1;\n    let last_block = msg_block;\n\n    // If we don't have room to write the size, compress the block and reset it.\n    if msg_byte_ptr > MSG_SIZE_PTR {\n        h = sha256_compression(msg_block, h);\n        // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n        msg_byte_ptr = 0;\n    }\n\n    msg_block = unsafe { attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size) };\n\n    if !is_unconstrained() {\n        verify_msg_len(msg_block, last_block, msg_byte_ptr, message_size);\n    }\n\n    hash_final_block(msg_block, h)\n}\n\n// Take `BLOCK_SIZE` number of bytes from `msg` starting at `msg_start`.\n// Returns the block and the length that has been copied rather than padded with zeros.\nunconstrained fn build_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_start: u32,\n) -> (MSG_BLOCK, BLOCK_BYTE_PTR) {\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n\n    // We insert `BLOCK_SIZE` bytes (or up to the end of the message)\n    let block_input = if msg_start + BLOCK_SIZE > message_size {\n        if message_size < msg_start {\n            // This function is sometimes called with `msg_start` past the end of the message.\n            // In this case we return an empty block and zero pointer to signal that the result should be ignored.\n            0\n        } else {\n            message_size - msg_start\n        }\n    } else {\n        BLOCK_SIZE\n    };\n\n    // Figure out the number of items in the int array that we have to pack.\n    // e.g. if the input is [0,1,2,3,4,5] then we need to pack it as 2 items: [0123, 4500]\n    let mut int_input = block_input / INT_SIZE;\n    if block_input % INT_SIZE != 0 {\n        int_input = int_input + 1;\n    };\n\n    for i in 0..int_input {\n        let mut msg_item: u32 = 0;\n        // Always construct the integer as 4 bytes, even if it means going beyond the input.\n        for j in 0..INT_SIZE {\n            let k = i * INT_SIZE + j;\n            let msg_byte = if k < block_input {\n                msg[msg_start + k]\n            } else {\n                0\n            };\n            msg_item = lshift8(msg_item, 1) + msg_byte as u32;\n        }\n        msg_block[i] = msg_item;\n    }\n\n    // Returning the index as if it was a 64 byte array.\n    // We have to project it down to 16 items and bit shifting to get a byte back if we need it.\n    (msg_block, block_input)\n}\n\n// Verify the block we are compressing was appropriately constructed by `build_msg_block`\n// and matches the input data. Returns the index of the first unset item.\n// If `message_size` is less than `msg_start` then this is called with the old non-empty block;\n// in that case we can skip verification, ie. no need to check that everything is zero.\nfn verify_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_block: MSG_BLOCK,\n    msg_start: u32,\n) -> BLOCK_BYTE_PTR {\n    let mut msg_byte_ptr = 0;\n    let mut msg_end = msg_start + BLOCK_SIZE;\n    if msg_end > N {\n        msg_end = N;\n    }\n    // We might have to go beyond the input to pad the fields.\n    if msg_end % INT_SIZE != 0 {\n        msg_end = msg_end + INT_SIZE - msg_end % INT_SIZE;\n    }\n\n    // Reconstructed packed item.\n    let mut msg_item: u32 = 0;\n\n    // Inclusive at the end so that we can compare the last item.\n    let mut i: u32 = 0;\n    for k in msg_start..=msg_end {\n        if k % INT_SIZE == 0 {\n            // If we consumed some input we can compare against the block.\n            if (msg_start < message_size) & (k > msg_start) {\n                assert_eq(msg_block[i], msg_item as u32);\n                i = i + 1;\n                msg_item = 0;\n            }\n        }\n        // Shift the accumulator\n        msg_item = lshift8(msg_item, 1);\n        // If we have input to consume, add it at the rightmost position.\n        if k < message_size & k < msg_end {\n            msg_item = msg_item + msg[k] as u32;\n            msg_byte_ptr = msg_byte_ptr + 1;\n        }\n    }\n\n    msg_byte_ptr\n}\n\n// Verify the block we are compressing was appropriately padded with zeros by `build_msg_block`.\n// This is only relevant for the last, potentially partially filled block.\nfn verify_msg_block_padding(msg_block: MSG_BLOCK, msg_byte_ptr: BLOCK_BYTE_PTR) {\n    // Check all the way to the end of the block.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_BLOCK_SIZE);\n}\n\n// Verify that a region of ints in the message block are (partially) zeroed,\n// up to an (exclusive) maximum which can either be the end of the block\n// or just where the size is to be written.\nfn verify_msg_block_zeros(\n    msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    max_int_byte_ptr: u32,\n) {\n    // This variable is used to get around the compiler under-constrained check giving a warning.\n    // We want to check against a constant zero, but if it does not come from the circuit inputs\n    // or return values the compiler check will issue a warning.\n    let zero = msg_block[0] - msg_block[0];\n\n    // First integer which is supposed to be (partially) zero.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        let zeros = INT_SIZE - modulo;\n        let mask = if zeros == 3 {\n            TWO_POW_24\n        } else if zeros == 2 {\n            TWO_POW_16\n        } else {\n            TWO_POW_8\n        };\n        assert_eq(msg_block[int_byte_ptr] % mask, zero);\n        int_byte_ptr = int_byte_ptr + 1;\n    }\n\n    // Check the rest of the items.\n    for i in 0..max_int_byte_ptr {\n        if i >= int_byte_ptr {\n            assert_eq(msg_block[i], zero);\n        }\n    }\n}\n\n// Verify that up to the byte pointer the two blocks are equal.\n// At the byte pointer the new block can be partially zeroed.\nfn verify_msg_block_equals_last(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n) {\n    // msg_byte_ptr is the position at which they are no longer have to be the same.\n    // First integer which is supposed to be (partially) zero contains that pointer.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Reconstruct the partially zero item from the last block.\n        let last_field = last_block[int_byte_ptr];\n        let mut msg_item: u32 = 0;\n        // Reset to where they are still equal.\n        msg_byte_ptr = msg_byte_ptr - modulo;\n        for i in 0..INT_SIZE {\n            msg_item = lshift8(msg_item, 1);\n            if i < modulo {\n                msg_item = msg_item + get_item_byte(last_field, msg_byte_ptr) as u32;\n                msg_byte_ptr = msg_byte_ptr + 1;\n            }\n        }\n        assert_eq(msg_block[int_byte_ptr], msg_item);\n    }\n\n    for i in 0..INT_SIZE_PTR {\n        if i < int_byte_ptr {\n            assert_eq(msg_block[i], last_block[i]);\n        }\n    }\n}\n\n// Apply a function on the block item which the pointer indicates.\nfn update_block_item<Env>(\n    mut msg_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    f: fn[Env](u32) -> u32,\n) -> MSG_BLOCK {\n    let i = msg_byte_ptr / INT_SIZE;\n    msg_block[i] = f(msg_block[i]);\n    msg_block\n}\n\n// Set the rightmost `zeros` number of bytes to 0.\nfn set_item_zeros(item: u32, zeros: u8) -> u32 {\n    lshift8(rshift8(item, zeros), zeros)\n}\n\n// Replace one byte in the item with a value, and set everything after it to zero.\nfn set_item_byte_then_zeros(msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR, msg_byte: u8) -> u32 {\n    let zeros = INT_SIZE - msg_byte_ptr % INT_SIZE;\n    let zeroed_item = set_item_zeros(msg_item, zeros as u8);\n    let new_item = byte_into_item(msg_byte, msg_byte_ptr);\n    zeroed_item + new_item\n}\n\n// Get a byte of a message item according to its overall position in the `BLOCK_SIZE` space.\nfn get_item_byte(mut msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR) -> u8 {\n    // How many times do we have to shift to the right to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    msg_item = rshift8(msg_item, shifts as u8);\n    // At this point the byte we want is in the rightmost position.\n    msg_item as u8\n}\n\n// Project a byte into a position in a field based on the overall block pointer.\n// For example putting 1 into pointer 5 would be 100, because overall we would\n// have [____, 0100] with indexes [0123,4567].\nfn byte_into_item(msg_byte: u8, msg_byte_ptr: BLOCK_BYTE_PTR) -> u32 {\n    let mut msg_item = msg_byte as u32;\n    // How many times do we have to shift to the left to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    lshift8(msg_item, shifts as u8)\n}\n\n// Construct a field out of 4 bytes.\nfn make_item(b0: u8, b1: u8, b2: u8, b3: u8) -> u32 {\n    let mut item = b0 as u32;\n    item = lshift8(item, 1) + b1 as u32;\n    item = lshift8(item, 1) + b2 as u32;\n    item = lshift8(item, 1) + b3 as u32;\n    item\n}\n\n// Shift by 8 bits to the left between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise multiplies by 256.\nfn lshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        if item == 0 {\n            0\n        } else {\n            // Brillig wouldn't shift 0<<4 without overflow.\n            item << (8 * shifts)\n        }\n    } else {\n        // We can do a for loop up to INT_SIZE or an if-else.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item * TWO_POW_8\n        } else if shifts == 2 {\n            item * TWO_POW_16\n        } else if shifts == 3 {\n            item * TWO_POW_24\n        } else {\n            // Doesn't make sense, but it's most likely called on 0 anyway.\n            0\n        }\n    }\n}\n\n// Shift by 8 bits to the right between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise divides by 256.\nfn rshift8(item: u32, shifts: u8) -> u32 {\n    if is_unconstrained() {\n        item >> (8 * shifts)\n    } else {\n        // Division wouldn't work on `Field`.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item / TWO_POW_8\n        } else if shifts == 2 {\n            item / TWO_POW_16\n        } else if shifts == 3 {\n            item / TWO_POW_24\n        } else {\n            0\n        }\n    }\n}\n\n// Zero out all bytes between the end of the message and where the length is appended,\n// then write the length into the last 8 bytes of the block.\nunconstrained fn attach_len_to_msg_block(\n    mut msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) -> MSG_BLOCK {\n    // We assume that `msg_byte_ptr` is less than 57 because if not then it is reset to zero before calling this function.\n    // In any case, fill blocks up with zeros until the last 64 bits (i.e. until msg_byte_ptr = 56).\n    // There can be one item which has to be partially zeroed.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Index of the block in which we find the item we need to partially zero.\n        let i = msg_byte_ptr / INT_SIZE;\n        let zeros = INT_SIZE - modulo;\n        msg_block[i] = set_item_zeros(msg_block[i], zeros as u8);\n        msg_byte_ptr = msg_byte_ptr + zeros;\n    }\n\n    // The rest can be zeroed without bit shifting anything.\n    for i in (msg_byte_ptr / INT_SIZE)..INT_SIZE_PTR {\n        msg_block[i] = 0;\n    }\n\n    // Set the last two 4 byte ints as the first/second half of the 8 bytes of the length.\n    let len = 8 * message_size;\n    let len_bytes: [u8; 8] = (len as Field).to_be_bytes();\n    for i in 0..=1 {\n        let shift = i * 4;\n        msg_block[INT_SIZE_PTR + i] = make_item(\n            len_bytes[shift],\n            len_bytes[shift + 1],\n            len_bytes[shift + 2],\n            len_bytes[shift + 3],\n        );\n    }\n    msg_block\n}\n\n// Verify that the message length was correctly written by `attach_len_to_msg_block`,\n// and that everything between the byte pointer and the size pointer was zeroed,\n// and that everything before the byte pointer was untouched.\nfn verify_msg_len(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) {\n    // Check zeros up to the size pointer.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_SIZE_PTR);\n\n    // Check that up to the pointer we match the last block.\n    verify_msg_block_equals_last(msg_block, last_block, msg_byte_ptr);\n\n    // We verify the message length was inserted correctly by reversing the byte decomposition.\n    let mut reconstructed_len: u64 = 0;\n    for i in INT_SIZE_PTR..INT_BLOCK_SIZE {\n        reconstructed_len = reconstructed_len * TWO_POW_32;\n        reconstructed_len = reconstructed_len + msg_block[i] as u64;\n    }\n    let len = 8 * message_size as u64;\n    assert_eq(reconstructed_len, len);\n}\n\n// Perform the final compression, then transform the `STATE` into `HASH`.\nfn hash_final_block(msg_block: MSG_BLOCK, mut state: STATE) -> HASH {\n    let mut out_h: HASH = [0; 32]; // Digest as sequence of bytes\n    // Hash final padded block\n    state = sha256_compression(msg_block, state);\n\n    // Return final hash as byte array\n    for j in 0..8 {\n        let h_bytes: [u8; 4] = (state[j] as Field).to_be_bytes();\n        for k in 0..4 {\n            out_h[4 * j + k] = h_bytes[k];\n        }\n    }\n\n    out_h\n}\n\n","path":"/Users/sanjaysirangi/nargo/github.com/noir-lang/sha256/v0.1.0/src/sha256.nr"}},"names":["main"],"brillig_names":["build_msg_block","attach_len_to_msg_block","directive_integer_quotient","directive_to_radix"]}