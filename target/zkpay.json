{"noir_version":"1.0.0-beta.3+ceaa1986628197bd1170147f6a07f0f98d21030a","hash":17450469962802539498,"abi":{"parameters":[{"name":"msg_hash","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"signature","type":{"kind":"array","length":64,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"pubkey_x","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"pubkey_y","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"}],"return_type":null,"error_types":{}},"bytecode":"H4sIAAAAAAAA/6WY93NUZRhGb4zGICIiIiKiQSyx72Z3k10biVhi772RwMbYe2/BGnvvChn+UnjmfjtzCGeGH7gzmXxzMrOTuXef5573Harqa+Xwz8FyHjr8M1x+5xpdxYaEnSBsWNiJwk4SNiLsZGGjwtYIO0XYWmGnClsn7DRh64WdLmyDsDOEbRR2prBNws4StlnY2cK2CDtH2FZh5wrbJuw8YecLGxO2XdgFwnYIu1DYRcIuFnaJsHFhlwq7TNjlwq4QdqWwq4RdLawhrClsQlhLWFtYR9iksClhXWE9YdcIu1bYdcKuF3aDsJ3CpoXNCLtR2C5hNwm7Wdgtwm4VNivsNmG3C7tD2J3C7hJ2t7B7hN0r7D5h9wt7QNiDwh4S9rCwR4Q9KuwxYY8Le0LYk8KeEva0sGeE7RY2J2xe2B5he4X1hS0Ie1bYorDnhD0v7AVhLwp7SdjLwl4R9qqw14S9LuwNYW8Ke0vY28LeEfausPeEvS/sA2EfCvtI2MfCPhG2JGyfsE+FfSbsc2FfCPtS2FfCloV9LewbYd8K+07Y98J+EPajsJ+E/SzsF2G/CvtN2O/C/hD2p7C/hP0t7B9h/wr7T9j/wvYLOwA2Uh3df3M4s+/24Mx+Y6+xz9hjizizt9hX7Cn2E3uJfcQeYv+wd9g37Bn2C3uFfcIeYX+wN9gX7An2A3uBfcAeWMJ5H87MO3POfDPXzDNzvIwzc8u8MqfMJ3PJPDKHzB9zx7wxZ8wXc8U8MUfMD3PDvDAnzAdzwTwwB2M4b8eZ884OnDnfcK7hPMM5Zhxnzi2cVzincD7hXMJ5hHMI5w/OHZw3OGdwvuBcwXmCcwTnB84NnBc4J3A+4FzAeYBzwDTOMzjT93fhTL+n19Pn6fGzONPb6ev0dPo5vZw+Tg+nf9O76dv0bPo1vZo+TY+mP9Ob6cv0ZPoxvZg+TA+ucB7CefW+aXDmfol7Je6TuEcaxZl7I+6LuCfifoh7Ie6DuAfi/od7H+57uOfhfod7He5zuMfh/oZ7G+5ruKfhfoZ7Ge5jBnuYlerIa/A8psvvxvFdzRV8Vqsx2W73pyb6zVZzrjHRm+92Gu3O/GS32W12up29E91Wq99td6d6872pRq/ZbvWbC51ea6F82ODZV6v+78F3Zbj8Pd+JEXwH1pRnvbY823XlWa4vz25DeVYby7PZVJ7F5nLvt5R7vbXc223lXuYejlV1Z6er09Hp5nRyujgdPF7VnZuuTcemW9Op6dJ0aLoznZmuTEemG9OJ6cJ0YLovnZeuS8el29Jp6bKd5d7OVHVXpaPSTemkdFE6aLaqOyddk45Jt6RT0iXpkHRHOiNdkY5IN6QT0gXpgGQ/mU/Wk/FkO5lOlpPh3VXtbHG1OFrcLE4WF4uDLVa1c8W14lhxqzhVXCoOFXeKM8WV4khxozhRXCgOFPeJ88R14jhxmzhNXCYOs1TVzhJXiaPETeIkcZE4yHJVO0dcI44Rt4hTxCXiEHGHOENcIY4QN4gTxAXiAHn3552fd33e8Xm3552ed3ne4ce6DgHebzD/fBcAAA==","debug_symbols":"bY1LCsMgFEX38sYZ1NYa6lZKCX6DICp+CkWy92qokEJm79zLua+CVLysi3HaJ6DPCtYLlo13jSogctnDFJjrnDKLGeiNoPsEysl+PvA2gTZWASVoe01NQqfSfMVDmjH6kxrwaKw163L83+I3i4Zxq36oixOHNn/CaIYfohdKlqj60t61+S8=","file_map":{"61":{"source":"// fn main(\n//     sender: [u8; 5], // ASCII bytes for \"Alice\"\n//     receiver: [u8; 3], // ASCII bytes for \"Bob\"\n//     amount: u64, // the payment amount (100)\n//     timestamp: [u8; 20], // ASCII bytes for \"2025-05-06T14:00:00Z\"\n//     payment_id: [u8; 9], // ASCII bytes for \"PAY123XYZ\"\n//     signature: [u8; 64], // ECDSA secp256r1 signature (r||s)\n//     claimed_amount: pub u64, // Publicly claimed amount\n// ) -> pub bool {\n//     // Known merchant public key (secp256r1 coordinates)\n//     let pub_x: [u8; 32] = [\n//         20, 134, 108, 210, 145, 254, 162, 45, 74, 20, 206, 144, 106, 68, 184, 108, 61, 203, 26, 193,\n//         56, 107, 66, 75, 252, 221, 79, 68, 88, 253, 100, 22,\n//     ];\n//     let pub_y: [u8; 32] = [\n//         157, 77, 62, 36, 55, 26, 124, 150, 207, 205, 33, 159, 167, 125, 59, 220, 34, 162, 131, 87,\n//         154, 69, 15, 93, 179, 7, 232, 205, 249, 88, 9, 210,\n//     ];\n\n//     // Concatenate fields into one message byte array:\n//     // \"Alice|Bob|100|2025-05-06T14:00:00Z|PAY123XYZ\"\n//     let message: [u8; 44] = [\n//         65, 108, 105, 99, 101, 124, // \"Alice|\"\n//         66, 111, 98, 124, // \"Bob|\"\n//         49, 48, 48, 124, // \"100|\"\n//         50, 48, 50, 53, 45, 48, 53, 45, 48, 54, 84, 49, 52, 58, 48, 48, 58, 48, 48, 90, 124, // \"2025-05-06T14:00:00Z|\"\n//         80, 65, 89, 49, 50, 51, 88, 89, 90, // \"PAY123XYZ\"\n//     ];\n//     let msg_hash: [u8; 32] = [\n//         81, 125, 30, 75, 48, 176, 58, 220, 201, 36, 71, 168, 98, 207, 249, 5, 242, 33, 182, 113,\n//         102, 171, 92, 83, 47, 139, 216, 181, 178, 132, 131, 149,\n//     ];\n//     print(\"input\");\n//     print(msg_hash);\n//     // Verify the ECDSA signature on secp256r1\n//     let sig_valid: bool = std::ecdsa_secp256r1::verify_signature(pub_x, pub_y, signature, msg_hash); // returns true if signature is valid:contentReference[oaicite:5]{index=5}\n//     // Check that the private `amount` matches the public claimed amount\n//     let amount_ok: bool = amount == claimed_amount;\n\n//     // Output true if both checks pass\n//     sig_valid\n// }\n\n// #[test]\n// fn test_valid_payment() {\n//     // Hardcode the receipt fields\n//     let sender: [u8; 5] = [65, 108, 105, 99, 101]; // \"Alice\"\n//     let receiver: [u8; 3] = [66, 111, 98]; // \"Bob\"\n//     let timestamp: [u8; 20] =\n//         [50, 48, 50, 53, 45, 48, 53, 45, 48, 54, 84, 49, 52, 58, 48, 48, 58, 48, 48, 90]; // \"2025-05-06T14:00:00Z\"\n//     let payment_id: [u8; 9] = [80, 65, 89, 49, 50, 51, 88, 89, 90]; // \"PAY123XYZ\"\n//     let signature: [u8; 64] = [\n//         39, 46, 174, 27, 176, 202, 95, 201, 150, 183, 27, 161, 251, 189, 113, 82, 116, 220, 219,\n//         193, 44, 83, 6, 55, 135, 60, 25, 10, 210, 243, 56, 224, 148, 2, 79, 200, 56, 154, 243, 136,\n//         157, 79, 135, 44, 191, 166, 194, 147, 15, 206, 124, 253, 88, 1, 198, 35, 5, 118, 22, 17,\n//         125, 22, 187, 66,\n//     ];\n//     // Call the circuit's main function and assert it returns true (signature valid, amounts match, etc.)\n//     assert(main(sender, receiver, 100, timestamp, payment_id, signature, 100) == true);\n// }\n// use sha256::sha256;\n\n// fn main(\n//     msg_hash\n//     signature: [u8; 64],\n//     pubkey\n// ) -> pub bool {\n//    // todo\n//     let sig_valid: bool = verify_sg_fintion\n\n//     sig_valid\n// }\n\n// #[test]\n// fn test_valid_payment() {\n//     let msg_hash: [] = [];\n//     let signature: [u8; 64] = [\n\n//     ];\n//     let pubkey; [] = [];\n\n//     assert(main(msg_hash, signature, pubkey) == true);\n// }\n\nfn main(msg_hash: [u8; 32], signature: [u8; 64], pubkey_x: [u8; 32], pubkey_y: [u8; 32]) {\n    let sig_valid: bool =\n        std::ecdsa_secp256k1::verify_signature(pubkey_x, pubkey_y, signature, msg_hash);\n    // sig_valid\n    assert(sig_valid == true)\n}\n\n#[test]\nfn test_valid_signature() {\n    let msg_hash: [u8; 32] = [\n        0xa0, 0x88, 0xa6, 0x01, 0x43, 0xf2, 0x6c, 0x71, 0x52, 0xdc, 0xd5, 0x73, 0x50, 0xd1, 0x90,\n        0x20, 0xb8, 0xff, 0x99, 0xce, 0xb6, 0x04, 0xf6, 0x1a, 0xdb, 0xc9, 0x36, 0x42, 0x05, 0x4e,\n        0x58, 0xdc,\n    ];\n\n    let signature: [u8; 64] = [\n        0x81, 0x75, 0x47, 0x4d, 0x40, 0x71, 0x9e, 0x86, 0xa1, 0xf0, 0x43, 0xcd, 0xf7, 0x02, 0xed,\n        0xe2, 0xb0, 0xe5, 0xe7, 0xf7, 0x2b, 0x8b, 0xd8, 0x17, 0x46, 0x73, 0xcc, 0x5f, 0x04, 0x10,\n        0x3c, 0x9b, 0x5a, 0xe3, 0x2a, 0x32, 0x94, 0x1f, 0x2f, 0x69, 0x57, 0xaa, 0x3c, 0xdb, 0x03,\n        0xd1, 0xc3, 0xf0, 0x8b, 0x94, 0xa4, 0xd5, 0x2c, 0xe8, 0x1f, 0xe8, 0x4d, 0x26, 0x65, 0x52,\n        0xca, 0xa3, 0x8e, 0x01,\n    ];\n\n    let pubkey_x: [u8; 32] = [\n        0x3c, 0xbe, 0x89, 0x92, 0x5a, 0xd6, 0xc4, 0x4b, 0x3f, 0x99, 0x0c, 0x29, 0x05, 0x93, 0x04,\n        0x03, 0xcb, 0x99, 0xff, 0x7c, 0xbc, 0x09, 0xd7, 0x5a, 0x0c, 0x9b, 0x3b, 0x81, 0xef, 0xf6,\n        0x27, 0x44,\n    ];\n\n    let pubkey_y: [u8; 32] = [\n        0xc1, 0x7e, 0xf7, 0xbc, 0xfc, 0x0d, 0xee, 0xe6, 0x3f, 0xfd, 0x35, 0x43, 0xdf, 0x28, 0x0f,\n        0x4c, 0x27, 0xb8, 0xbb, 0xdb, 0xa5, 0x31, 0xeb, 0x85, 0x82, 0x01, 0x04, 0xc5, 0x70, 0x85,\n        0xa1, 0x03,\n    ];\n\n    // assert(main(msg_hash, signature, pubkey_x, pubkey_y) == true);\n}\n\n// rsa_verification.nr\n\n// struct BigInt256 {\n//     limbs: [u128; 16], // 2048 bits\n// }\n\n// // Add two BigInts (no modulus)\n// fn bigint_add(a: BigInt256, b: BigInt256) -> BigInt256 {\n//     let mut result = BigInt256 { limbs: [0 as u128; 16] };\n//     let mut carry = 0 as u128;\n\n//     for i in 0..16 {\n//         let (sum, new_carry) = std::num::add_with_carry(a.limbs[i], b.limbs[i], carry);\n//         result.limbs[i] = sum;\n//         carry = new_carry;\n//     }\n\n//     result\n// }\n\n// // Multiply two BigInts (no modulus), naive O(n^2)\n// fn bigint_mul(a: BigInt256, b: BigInt256) -> BigInt256 {\n//     let mut result = BigInt256 { limbs: [0 as u128; 16] };\n\n//     for i in 0..16 {\n//         let mut carry = 0 as u128;\n//         for j in 0..(16 - i) {\n//             let idx = i + j;\n//             let prod = a.limbs[i] * b.limbs[j] + result.limbs[idx] + carry;\n//             result.limbs[idx] = prod & ((1 << 128) - 1);\n//             carry = prod >> 128;\n//         }\n//     }\n\n//     result\n// }\n\n// // Simple modulus: assumes dividend < 2 * modulus\n// // (not efficient; works if you know decrypted < 2n)\n// fn bigint_mod(dividend: BigInt256, modulus: BigInt256) -> BigInt256 {\n//     // Compare dividend >= modulus\n//     let mut greater = false;\n//     for i in (0..16).rev() {\n//         if dividend.limbs[i] > modulus.limbs[i] {\n//             greater = true;\n//             break;\n//         } else if dividend.limbs[i] < modulus.limbs[i] {\n//             greater = false;\n//             break;\n//         }\n//     }\n\n//     if greater {\n//         // Subtract modulus\n//         bigint_sub(dividend, modulus)\n//     } else {\n//         dividend\n//     }\n// }\n\n// // Subtract b from a (assume a >= b)\n// fn bigint_sub(a: BigInt256, b: BigInt256) -> BigInt256 {\n//     let mut result = BigInt256 { limbs: [0 as u128; 16] };\n//     let mut borrow = 0 as u128;\n\n//     for i in 0..16 {\n//         let (diff, new_borrow) = std::num::sub_with_borrow(a.limbs[i], b.limbs[i], borrow);\n//         result.limbs[i] = diff;\n//         borrow = new_borrow;\n//     }\n\n//     result\n// }\n\n// // Modular exponentiation: (base ^ exponent) % modulus\n// fn modexp(base: BigInt256, exponent: u32, modulus: BigInt256) -> BigInt256 {\n//     let mut result = BigInt256 { limbs: [0 as u128; 16] };\n//     result.limbs[0] = 1; // result = 1\n\n//     let mut base_acc = base;\n//     let mut exp = exponent;\n\n//     while exp > 0 {\n//         if exp & 1 == 1 {\n//             result = bigint_mul(result, base_acc);\n//             result = bigint_mod(result, modulus);\n//         }\n//         base_acc = bigint_mul(base_acc, base_acc);\n//         base_acc = bigint_mod(base_acc, modulus);\n//         exp = exp >> 1;\n//     }\n\n//     result\n// }\n\n// // --- MAIN RSA VERIFY ---\n\n// fn main(\n//     msg_hash: [u8; 32],\n//     signature: BigInt256,\n//     modulus: BigInt256,\n//     exponent: u32, // usually 65537\n// ) -> pub bool {\n//     let decrypted = modexp(signature, exponent, modulus);\n\n//     // Build expected ASN.1 DigestInfo block\n//     let asn1_prefix: [u8; 19] = [\n//         0x30, 0x31, 0x30, 0x0d, 0x06, 0x09, 0x60, 0x86, 0x48, 0x01,\n//         0x65, 0x03, 0x04, 0x02, 0x01, 0x05, 0x00, 0x04, 0x20\n//     ];\n\n//     // Convert decrypted BigInt into bytes (limbs are little-endian; overall we assume big-endian)\n//     let mut decrypted_bytes = [0; 256];\n//     for i in 0..16 {\n//         let limb = decrypted.limbs[i];\n//         for j in 0..16 {\n//             decrypted_bytes[i * 16 + j] = ((limb >> (8 * j)) & 0xff) as u8;\n//         }\n//     }\n\n//     // Look for ASN.1 + hash at the END of decrypted_bytes (PKCS1v1.5 padding)\n//     let mut valid = true;\n\n//     // Check ASN.1 prefix (19 bytes before the hash)\n//     for i in 0..19 {\n//         if decrypted_bytes[256 - 32 - 19 + i] != asn1_prefix[i] {\n//             valid = false;\n//         }\n//     }\n\n//     // Check hash matches\n//     for i in 0..32 {\n//         if decrypted_bytes[256 - 32 + i] != msg_hash[i] {\n//             valid = false;\n//         }\n//     }\n\n//     valid\n// }\n","path":"/Users/sanjaysirangi/Desktop/zkpay/src/main.nr"}},"names":["main"],"brillig_names":[]}